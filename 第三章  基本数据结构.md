# 第三章  基本数据结构



### 3.1  什么是线性数据结构

有序的数据集合，元素的顺序取决于添加顺序或移除顺序，添加某个元素时，与前后元素的相对位置保持不变。



### 3.2  栈

#### 3.2.1  栈的基本概念

有序集合，其添加操作和移除操作总发生在同一端(顶端)，栈中的元素离底端越近，在栈中的时间越长，而新添加的元素先被移除，这种排序原则称为LIFO，即后进先出。故只能在顶端进行操作。

栈的反转特性：

![](https://cdn.jsdelivr.net/gh/20220310/python-1/202301172025574.PNG)

#### 3.2.2  栈的基本操作

code 3-1:

```python
class Stack:
    def __init__(self):
        self.items=[]

    def isEmpty(self):
        return self.items==[]

    def push(self,item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[len(self.items)-1]

    def size(self):
        return len(self.items)

s=Stack()
#isEmpty()检查栈是否为空，空为True
print(s.isEmpty())
#push(item)向栈中添加一个元素
s.push('dog')
s.push(4)
#peek()返回栈顶端的元素，但是并不移除该元素
print(s.peek())
s.push(True)
#size()返回栈的大小
print(s.size())
s.push(8.4)
#pop()删除栈顶端的元素，会修改栈的内容
print(s.pop())
print(s.isEmpty())
```

输出：

```python
True
4
3
8.4
False
```

#### 3.2.3  匹配括号

即每一个左括号都有一个与之相对应的右括号，并且括号对有正确的嵌套关系。

接下来利用栈的思想解决括号是否匹配的问题：

code 3-2:

```python
from pythonds.basic import Stack

def parChecker(symbol):
    s=Stack()
    balanced=True
    index=0
    while index<len(symbol) and balanced:
        symbol_s=symbol[index]
        #条件分支，如果是左括号，放入栈中；如果栈为空(可能右括号先出现，显然不匹配，可能传入的字符串为空)，跳出循环；如果为右括号，删除栈中的顶端元素
        if symbol_s=='(':
            s.push(symbol)
        else:
            if s.isEmpty():
                balanced=False
            else:
                s.pop()
        index=index+1
    #左右括号一一对应时返回True
    if balanced and s.isEmpty():
        return True
    else:
        return False

l='((())))'
print(parChecker(l))
```

输出：

```python
False
```

通过上述程序可知，利用栈可以很好的解决括号的匹配问题，因为从左往右检查，第一个左括号与最后一个右括号匹配，可以先放入栈中，后放入的左括号先被删除，表示与其匹配的右括号先对应(即由内而外匹配剔除，直到最外层的左右括号)。

拓展解决多种括号的匹配问题：

code 3-3:

```python
from pythonds.basic import Stack

def parChecker(symbol):
    s=Stack()
    balanced=True
    index=0
    while index<len(symbol) and balanced:
        symbol_s=symbol[index]
        if symbol_s in '([{':
            s.push(symbol_s)
        else:
            if s.isEmpty():
                balanced=False
            else:
                #用于匹配删除的左括号与当前的右括号，若不匹配，则直接跳出循环
                top=s.pop()
                if not matches(top,symbol_s):
                    balanced=False
        index=index+1
    if balanced and s.isEmpty():
        return True
    else:
        return False

def matches(open,close):
    opens='([{'
    closers=')]}'
    #返回opens和closers的某个字符的索引，not matches表示两个索引不相同，即括号不对应
    return opens.index(open)==closers.index(close)

l='{([])}'
print(parChecker(l))
```

输出：

```python
True
```

通过上述两个例子，说明任何记法都需要正确的匹配和嵌套符号。

#### 3.2.4  十进制转化为二进制

对于一个十进制的数，将其反复除以2取余，直到商为0，余数反向排列即为二进制数，即除2取余，逆向排列，当中又体现了反转特性，因此可用栈来解决，如下图：

![](https://cdn.jsdelivr.net/gh/20220310/python-1/202301172025771.PNG)

code 3-4:

```python
from pythonds.basic import Stack

def divideBy2(decnumber):
    remstack=Stack()

    while decnumber>0:
        rem=decnumber%2
        remstack.push(rem)
        decnumber=decnumber//2
    binstring=''
    #将余数取出(按照栈的顺序)，组成binstring
    while not remstack.isEmpty():
        binstring=binstring+str(remstack.pop())
    return binstring

num=345
print(divideBy2(num))
```

输出：

```python
101011001
```

同样地，可以将十进制数转化为2--16中的任一进制数，只需要添加一个参数(基数)，但是对于超过10的基数，不能直接使用余数，因为余数本身也是十进制数，因此使用字母来进行替代：

code 3-5:

```python
from pythonds.basic import Stack

def divideBy2(decnumber,base):
    remstack=Stack()
    #替换式，0--9依然表示数字0--9，A--F表示数字10--15
    digits='0123456789ABCDEF'

    while decnumber>0:
        rem=decnumber%base
        remstack.push(rem)
        decnumber=decnumber//base
    binstring=''
    while not remstack.isEmpty():
        binstring=binstring+digits[remstack.pop()]
    return binstring

num=1234
n=12
print(divideBy2(num,n))
```

输出：

```python
86A
```

#### 3.2.5  前序、中序和后序表达式

像$A*B$这样的表达式，$*$出现在两个变量中间，所以这种表达式称作中序表达式，如果是复杂运算：$A+B*C$，通过改变运算符与操作数的相对位置，可以得到前序表达式和后序表达式，通俗理解就是运算符在操作数之前(前序表达式)，后序表达式则相反，具体如下表：

<center>表3-1  中序、前序与后序表达式</center>

| 中序表达式 | 前序表达式 | 后序表达式 |
| :--------: | :--------: | :--------: |
|   A + B    |   + A B    |   A B +    |
| A + B * C  | + A * B C  | A B C * +  |

对于中序表达式，当需要提高某一运算的优先级时，可以加入括号，而前序表达式和后序表达式的运算顺序完全由运算符的位置决定，因此中序表达式是最不理想的算式。

**将中序转换为前序和后序表达式**

首先可以将中序表达式写成完全括号表达式：$A+B*C$---->$(A+(B*C))$，可以发现，每一对括号对应一个运算符，如果用运算符替换相应的右括号，那么可以得到后序表达式；用运算符替换相应的左括号，得到的就是前序表达式：

![](https://cdn.jsdelivr.net/gh/20220310/python-1/202301172026312.PNG)

![](https://cdn.jsdelivr.net/gh/20220310/python-1/202301172026819.PNG)

因此就实现了中序表达式和前序、后序表达式的互换。接下来通过程序来实现从中序向后序的转换：

code 3-6:

```python
from pythonds.basic import Stack
import string

def middle_to_lastfix(fixer):
    #创建一个字典，用于表示各运算符的优先级，其中左括号的优先级最低
    prec={}
    prec['*']=3
    prec['/']=3
    prec['+']=2
    prec['-']=2
    prec['(']=1

    opStack=Stack()
    #创建一个列表，用于存储所有符号
    postfixlist=[]
    #使用字符串方法中的split，将其分隔为单个字符
    tokenlist=fixer.split()

    for token in tokenlist:
        #判定如果字符属于A--Z中的一个，则加入到postfixlist中
        if token in string.ascii_uppercase:
            postfixlist.append(token)
        #如果是左括号，将其压入栈中
        elif token=='(':
            opStack.push(token)
        #如果是右括号，反复从栈中移除元素，直到移除对应的左括号，将取出的运算符加入到postfixlist中
        elif token==')':
            toptoken=opStack.pop()
            while toptoken != '(':
                postfixlist.append(toptoken)
                toptoken=opStack.pop()
        else:
            #如果字符是运算符，通过比较优先级，取出优先级更高或相等的运算符（没有就继续存入栈中），并添加到列表里
            while (not opStack.isEmpty()) and \
                    (prec[opStack.peek()] >= prec[token]):
                postfixlist.append(opStack.pop())
            opStack.push(token)
    while not opStack.isEmpty():
        postfixlist.append(opStack.pop())
    #将列表以字符串的方式返回(含空格)
    return ' '.join(postfixlist)

s='( A + B ) * ( C + D )'
print(middle_to_lastfix(s))
```

输出：

```python
A B + C D + *
```

**计算后序表达式**

考虑一个实际的后序表达式 7   8  +  3   2  +  /​，计算实际结果，由于压入栈的顺序是从左至右，会首先遇到操作数7,8，在遇到运算符+时就会对最近压入的两个数进行加法运算，得到的结果继续压入栈中，依此继续计算，直到栈中只有一个数，输出结果，而由于除法的运算受到数的顺序影响(15/5和5/15的结果不同)，考虑到出栈顺序，因此需要注意。

![](https://cdn.jsdelivr.net/gh/20220310/python-1/202301172026675.PNG)

下面通过代码实现后序表达式的计算：

code 3-7:

```python
from pythonds.basic import Stack

def lastcal(fixer):
    operandStack=Stack()
    tokenlist=fixer.split()

    for token in tokenlist:
        #将操作数作为整形数据压入栈中
        if token in '0123456789':
            operandStack.push(int(token))
        else:
            #依次取出操作数，进行运算，将结果再次压入栈中，1,2的顺序不能颠倒
            operand2=operandStack.pop()
            operand1=operandStack.pop()
            result=doMath(token,operand1,operand2)
            operandStack.push(result)
    return operandStack.pop()

def doMath(op,op1,op2):
    if op=='*':
        return op1*op2
    elif op=='/':
        return op1/op2
    elif op=='+':
        return op1+op2
    else:
        return op1-op2

s='7 8 + 3 2 + /'
print(lastcal(s))
```

输出：

```python
3.0
```



### 3.3  队列

#### 3.3.1  队列的概念与性质

同为有序集合，添加操作在“尾部”，移除操作在“头部”，先进先出，这种排序原则称为FIFO。

接下来使用python实现队列的操作：

code 3-8:

```python
class Queue:
    def __init__(self):
        self.items=[]

    def isEmpty(self):
        return self.items==[]

    def enqueue(self,item):
        self.items.insert(0,item)

    def dequeue(self):
        return self.items.pop()

    def size(self):
        return len(self.items)

q=Queue()
#isEmpty()判断q是否为空，是返回True
print(q.isEmpty())
#enqueue()插入元素
q.enqueue('dog')
q.enqueue(4)
print(q.isEmpty())
#返回q的大小
print(q.size())
#dequeue()移除元素
print(q.dequeue())
```

输出：

```python
True
False
2
dog
```

#### 3.3.2  模拟传土豆

考虑一个游戏：土豆在大家之间传递，某时土豆在谁手上谁就出局，重复上述过程，直到只剩下一个人：

![](https://cdn.jsdelivr.net/gh/20220310/python-1/202301172026615.PNG)

code 3-8:

```python
from pythonds.basic import Queue

def hotPotato(namelist,num):
    s=Queue()
    #将人名依次添加到队列中
    for name in namelist:
        s.enqueue(name)

    while s.size()>1:
        #队列头部的人被移出添加到队尾，直到游戏暂停，拿到土豆的人(即排头)移出队伍，如此循环
        for i in range(num):
            s.enqueue(s.dequeue())
        s.dequeue()

    return s.dequeue()

print(hotPotato(['Bill','David','Susan','Jane','Kent','Brad'],7))
```

输出：

```python
Susan
```

#### 3.3.3  模拟打印

对于一个连接多台电脑的打印机，只能打印先到的任务，后来的任务排在后面，考虑如下情景：实验室里有10名学生等待打印，在规定的1小时内最多打印两次，且页数1--20页不等，打印机每分钟低质量打印10页或者高质量打印5页，问如何根据情况设置打印速度。

据分析，1小时需要处理20个任务，每180秒1个任务，因此可以用1--180内的一个随机数模拟每秒内创建打印任务的概率，如果正好是180，表示有一个任务被创建，同时有可能多个任务被同时创建。

用程序实现这个任务：

code 3-9:

```python
from pythonds.basic import Queue
import random

class Printer:
    def __init__(self,ppm):
        #参数：打印机每分钟打印页数，打印任务(是/否)，打印时间
        self.pagerate=ppm
        self.currenttask=None
        self.timeRemaining=0

    def tick(self):
        #打印机打印一秒，从打印时间中减去一秒
        if self.currenttask != None:
            self.timeRemaining=self.timeRemaining-1
            if self.timeRemaining <= 0:
                self.currenttask=None

    def busy(self):
        #判断打印机是否空闲
        if self.currenttask !=None:
            return True
        else:
            return False

    def startNext(self,newtask):
        #计算打印时间，*60表示在秒数位上计算
        self.currenttask=newtask
        self.timeRemaining=newtask.getPages()*60/self.pagerate

class Task:
    def __init__(self,time):
        #参数，时间戳，打印页数
        self.timestamp=time
        self.pages=random.randrange(1,21)

    def getStamp(self):
        return self.timestamp

    def getPages(self):
        return self.pages

    def waitTime(self,currenttime):
        #当前时间与任务创建时间之差，即等待时间
        return currenttime-self.timestamp

def simulation(numSeconds,paperMinute):
    labprinter=Printer(paperMinute)
    #创建打印队列
    printQueue=Queue()
    waitingtimes=[]

    #在3600秒中循环，如果有任务被创建，内部程序执行
    for currentSecond in range(numSeconds):
        #如果有任务，将当前时间和打印页数传入队列中
        if newPrinttask():
            task=Task(currentSecond)
            printQueue.enqueue(task)

        #如果打印机空闲且有打印任务，则执行
        if (not labprinter.busy()) and \
                (not printQueue.isEmpty()):
            #取出最先的任务打印
            nexttask=printQueue.dequeue()
            #记录等待时间
            waitingtimes.append(\
                nexttask.waitTime(currentSecond))
            #计算打印需要的时间
            labprinter.startNext(nexttask)
        labprinter.tick()

    #计算平均等待时间并输出
    averageWait=sum(waitingtimes)/len(waitingtimes)
    print('Average wait %6.2f secs %3d tasks remaining.'%(averageWait,printQueue.size()))

def newPrinttask():
    #1--180内的随机数，如果为180，表明有一个任务被创建
    num=random.randrange(1,181)
    if num==180:
        return True
    else:
        return False

for i in range(10):
    #2个小时，每分钟打印5页
    simulation(3600,5)
    
for i in range(10):
    #2个小时，每分钟打印10页
    simulation(3600,10)
```

输出：

```python
Average wait  59.31 secs   1 tasks remaining.
Average wait  25.68 secs   0 tasks remaining.
Average wait  75.95 secs   2 tasks remaining.
Average wait 125.11 secs   4 tasks remaining.
Average wait 131.10 secs   1 tasks remaining.
Average wait  56.92 secs   0 tasks remaining.
Average wait  36.67 secs   0 tasks remaining.
Average wait  46.29 secs   1 tasks remaining.
Average wait  74.65 secs   0 tasks remaining.
Average wait 244.18 secs   4 tasks remaining.

Average wait  10.12 secs   0 tasks remaining.
Average wait  11.22 secs   0 tasks remaining.
Average wait  17.25 secs   0 tasks remaining.
Average wait  38.88 secs   0 tasks remaining.
Average wait   6.00 secs   0 tasks remaining.
Average wait  23.65 secs   0 tasks remaining.
Average wait   9.89 secs   0 tasks remaining.
Average wait  13.56 secs   0 tasks remaining.
Average wait   5.00 secs   0 tasks remaining.
Average wait  27.48 secs   0 tasks remaining.
```

通过上面的结果可知，降低打印速度，剩余的任务少，同时等待时间也少。



### 3.4  双端队列

双端队列同为有序集合，可以在前端和后端添加和删除元素。

#### 3.4.1  双端队列的实现

code 3-10:

```python
class Deque:
    def __init__(self):
        self.items=[]

    def isEmpty(self):
        return self.items==[]

    def addFront(self,item):
        self.items.append(item)

    def addRear(self,item):
        self.items.insert(0,item)

    def removeFront(self):
        return self.items.pop()

    def removeRear(self):
        return self.items.pop(0)

    def size(self):
        return len(self.items)

d=Deque()
#判断双端队列是否为空
print(d.isEmpty())
#将元素添加到队列后端
d.addRear(4)
d.addRear('dog')
#将元素添加到队列前端
d.addFront('cat')
d.addFront(True)
#返回双端队列的大小
print(d.size())
#移除队列的后端元素
print(d.removeRear())
#移除队列的前端元素
print(d.removeFront())
```

输出：

```python
True
4
dog
True
```

#### 3.4.2  回文检测器

回文是指从前往后读和从后往前读都是一样的字符串，利用双端队列的性质可以实现对回文字符串的检测：

code 3-11:

```python
from pythonds.basic import Deque

def palchecker(aSrting):
    cDeque=Deque()

    #将取出的字符在后端加入到双端队列中
    for ch in aSrting:
        cDeque.addRear(ch)

    stillEqual=True

    #在双端队列还未取完之前，每次从前端和后端取出一个字符比对是否相同，不相同则不是回文字符串，      退出循环
    while cDeque.size() >1 and stillEqual:
        first=cDeque.removeFront()
        last=cDeque.removeRear()
        if first !=last:
            stillEqual=False

    return stillEqual

print(palchecker('toot'))
```

输出：

```python
True
```



### 3.5  列表

列表是无序集合，且列表中没有重复元素；

为了实现无序列表，需要构造链表，链表能够通过连接元素确定它们的相对位置，因此首先要有第一个元素(头)的位置，最后一个元素需要知道自己没有下一个元素，按照链表的性质，可以实现无序列表。

**1.Node(节点)类**

节点是构造链表的基本数据结构，每一个节点都包括：列表元素，即数据变量；包含指向下一节点的引用。在构造节点时，需要提供初始值，下面结合python实现node类的基本操作：

code 3-12:

```python
class Node:
    def __init__(self,initdata):
        #设定初始值和下一节点的引用，None表明后面没有元素
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    #设定新节点
    def setData(self,newdata):
        self.data=newdata

    #设定新引用
    def setNext(self,newnext):
        self.next=newnext

n=Node(2)
print(n.getData())
```

输出：

```python
2
```

**2. UnorderedList(无序列表)类**

无序列表是基于节点来构建的，因此只要知道第一个节点的位置，其后的每一个元素都能通过下一个引用找到，下面的程序用来实现UnorderedList类：
code 3-13:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class UnorderedList:
    def __init__(self):
        self.head=None

    def isEmpty(self):
        return self.head==None

    #添加操作，先创建节点，再加入引用
    def add(self,item):
        temp=Node(item)
        temp.setNext(self.head)
        self.head=temp

    #求列表的长度，遍历实现
    def length(self):
        current=self.head
        count=0
        while current != None:
            count=count+1
            current=current.getNext()
        return count

    #遍历是否存在指定元素
    def search(self,item):
        current=self.head
        found=False
        while current != None and not found:
            if current.getData()==item:
                found=True
            else:
                current=current.getNext()
        return found

    #移除指定元素
    def remove(self,item):
        current=self.head
        previous=None
        found=False
        while not found:
            if current.getData()==item:
                found=True
            else:
                previous=current
                current=current.getNext()
        if previous==None:
            self.head=current.getNext()
        else:
            previous.setNext(current.getNext())

mylist=UnorderedList()
mylist.add(31)
mylist.add(77)
mylist.add(17)
mylist.add(93)
mylist.add(26)
mylist.add(54)
print(mylist.search(17))
mylist.remove(18)
```

输出：

```python
True
```

**3.有序列表**

有序列表中元素的相对位置取决于它们的基本特征，如按升序或降序排列；和无序列表类似，有序列表也有add(),remove()等操作：
code 3-14:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class OrderedList:
    def __init__(self):
        self.head=None

    def search(self,item):
        current=self.head
        found=False
        stop=False
        while current != None and not found and not stop:
            if current.getData()==item:
                found=True
            else:
                if current.getData()>item:
                    stop=True
                else:
                    current=current.getNext()

        return found

    def add(self,item):
        current=self.head
        previous=None
        stop=False
        while current != None and not stop:
            if current.getData()>item:
                stop=True
            else:
                previous=current
                current=current.getNext()

        temp=Node(item)
        if previous==None:
            temp.setNext(self.head)
            self.head=temp
        else:
            temp.setNext(current)
            previous.setNext(temp)

myList=OrderedList()
myList.add(1)
myList.add(2)
myList.add(4)
myList.add(5)
print(myList.search(12))
myList.add(3)
```

输出：

```python
False
```

无序列表的remove方法在删除元素后需要提供一个新的引用，由该处的上一节点指向下一节点，因此需要再加入一个引用previous，在current后面移动，有序列表的add操作也相似，因为可以在列表的任一位置插入，对于有序和无序列表的最后一个节点，引用必须"接地"。



------

### 作业

1.修改从中序到后序的转换算法，使其能处理异常情况

answer 1:

```python
from pythonds.basic import Stack
import string

def middle_to_lastfix(fixer):
    try:
        prec = {}
        prec['*'] = 3
        prec['/'] = 3
        prec['+'] = 2
        prec['-'] = 2
        prec['('] = 1

        opStack = Stack()
        postfixlist = []
        tokenlist = fixer.split()

        for token in tokenlist:
            if token in string.ascii_uppercase:
                postfixlist.append(token)
            elif token == '(':
                opStack.push(token)
            elif token == ')':
                toptoken = opStack.pop()
                while toptoken != '(':
                    postfixlist.append(toptoken)
                    toptoken = opStack.pop()
            else:
                while (not opStack.isEmpty()) and \
                        (prec[opStack.peek()] >= prec[token]):
                    postfixlist.append(opStack.pop())
                opStack.push(token)
        while not opStack.isEmpty():
            postfixlist.append(opStack.pop())
        return ' '.join(postfixlist)

    except:
        return '中序表达式错误'

s=' A + B ) * ( C + D )'
print(middle_to_lastfix(s))
```

output：

```python
中序表达式错误
```

2.修改计算后序表达式的算法，使其能处理异常情况

answer 2:

```python
from pythonds.basic import Stack

def lastcal(fixer):
    try:
        operandStack = Stack()
        tokenlist = fixer.split()

        for token in tokenlist:
            if token in '0123456789':
                operandStack.push(int(token))
            else:
                operand2 = operandStack.pop()
                operand1 = operandStack.pop()
                result = doMath(token, operand1, operand2)
                operandStack.push(result)
        return operandStack.pop()

    except:
        return '后序表达式错误'

def doMath(op,op1,op2):
    if op=='*':
        return op1*op2
    elif op=='/':
        return op1/op2
    elif op=='+':
        return op1+op2
    else:
        return op1-op2

s=' 8 + 3 2 + /'
print(lastcal(s))
```

output:

```python
后序表达式错误
```

3.结合从中序到后序的转换算法以及计算后序表达式的算法，实现直接的中序计算(在计算时，应该使用两个栈从左往右处理中序表达式，一格栈用于保存运算符，另一个用于保存操作数)

answer 3:

```python
from pythonds.basic import Stack

#该算法只能处理完全表达式之间的运算，且操作数范围为0--9
def middle_cal(fixer):
    try:
        s1=Stack()
        s2=Stack()
        tokenList=fixer.split()

        for token in tokenList:
            if token in '0123456789':
                s2.push(int(token))
            elif token=='(':
                s1.push(token)
            elif token==')':
                operand2=s2.pop()
                operand1=s2.pop()
                take=s1.pop()
                result=doMath(take,operand1,operand2)
                s2.push(result)
                while take != '(':
                    take=s1.pop()
            else:
                s1.push(token)

        return s2.pop()

    except:
        return '中序表达式错误'

def doMath(op,op1,op2):
    if op=='*':
        return op1*op2
    elif op=='/':
        return op1/op2
    elif op=='+':
        return op1+op2
    else:
        return op1-op2

s='( ( 8 / 2 ) * ( 5 + 4 ) )'
print(middle_cal(s))
```

output：

```python
36.0
```

4.使用列表实现队列抽象数据类型，将列表的后端作为队列的尾部

answer 4:

```python
class queue:
    def __init__(self):
        self.s=[]

    def enqueue(self,a):
        return self.s.append(a)

    def dequeue(self):
        return self.s.pop(0)

    def size(self):
        return len(self.s)

q=queue()
q.enqueue(4)
q.enqueue(6)
print(q.size())
print(q.dequeue())
```

output:

```python
2
4
```

5.设计和实现一个实验，对比两种队列实现的性能

answer 5:

```python
from pythonds.basic import Deque
from pythonds.basic import Queue
import time

def deque(atring):
    start=time.time()
    d=Deque()
    for ch in atring:
        d.addFront(ch)
    while d.size()>1:
        d.removeFront()
    end=time.time()

    return print('双端队列运行完成,运行时间%10.7f'%(end-start))

def queue(atring):
    start=time.time()
    q=Queue()
    for ch in atring:
        q.enqueue(ch)
    while q.size()>1:
        q.dequeue()
    end=time.time()

    return print('队列运行完成,运行时间%10.7f'%(end-start))

l=list(range(10000))
s1=deque(str(l))
s2=queue(str(l))
```

output:

```python
双端队列运行完成,运行时间 0.0199325
队列运行完成,运行时间 0.6488619
```

显然双端队列的性能要优于队列。

6.修改土豆模拟程序，允许随机计数，从而使每一轮的结果都不可预测

answer 6:

```python
from pythonds.basic import Queue
import random

def hotPotato(namelist):
    s=Queue()
    for name in namelist:
        s.enqueue(name)

    while s.size()>1:
        for i in range(random.randint(1,s.size()*10)):
            s.enqueue(s.dequeue())
        s.dequeue()

    return s.dequeue()

for i in range(5):
    print(hotPotato(['Bill','David','Susan','Jane','Kent','Brad']))
```

output:

```python
Brad
Bill
David
Jane
Kent
```

7.实现一个基数排序器，借用1个主桶和10个数位桶，每个桶为一个队列，并且按照数字到达的先后顺序来维持其中的值，算法要求：所有数字首先在主桶中，然后按照数值中每一个数位来考察这些值，比如个位的话，534将被放入4号桶中，重复十位，百位等等，一旦所有的值都被放在了相应的数位桶中，便依次从0号到9号数位桶将值放回主桶，最后的结果就是排序结果。

answer 7:

```python
from pythonds.basic import Queue

def Cardinalitysort(alist):
    result=[]
    main_queue=Queue()
    s=[]
    length=len(alist)
    longest_num=0
    for i in range(10):
        s.append(Queue())
    for num in alist:
        longest_num=max(len(str(num)),longest_num)
        main_queue.enqueue(num)
    for i in range(1,longest_num+1):
        for _ in range(length):
            s_queue=main_queue.dequeue()
            if len(str(s_queue))<i:
                main_queue.enqueue(s_queue)
            else:
                n=str(s_queue)[-i]
                s[int(n)].enqueue(s_queue)
        for j in range(10):
            while not s[j].isEmpty():
                main_queue.enqueue(s[j].dequeue())
    while not main_queue.isEmpty():
        result.append(main_queue.dequeue())

    return result

l=[1,12,1234,123,902,2022,678]
print(Cardinalitysort(l))
```

output:

```python
[1, 12, 123, 678, 902, 1234, 2022]
```

8.编写一个算法用于判断HTML文档的标签是否配套

answer 8:

```python
from pythonds.basic import Stack

def html_matching(filename):
    s1=Stack()
    s2=Stack()
    balanced=True
    txt=open(filename).readlines()
    for t in txt:
        item=0
        while item<len(t) and balanced:
            if t[item]=='<' and t[item+1]!='/':
                item=item+1
                while t[item]!='>':
                    s1.push(t[item])
                    item=item+1
            elif t[item]=='<' and t[item+1]=='/':
                item=item+2
                while t[item]!='>':
                    s2.push(t[item])
                    item=item+1
                compared=True
                while compared and not s1.isEmpty() and not s2.isEmpty():
                    item1=s1.pop()
                    item2=s2.pop()
                    if item1!=item2:
                        compared=False
                        balanced=False
            else:
                item=item+1
    if s1.isEmpty() and s2.isEmpty() and balanced:
        return print('文档标签匹配')
    else:
        return print('文档标签不匹配')

html_matching('html.txt')
```

output:

```python
文档标签匹配
```

html.txt文件内容如下：

```
<html>
    <head>
        <title>
            Example
        </title>
    </head>

    <body>
        <h1>Hello,world</h1>
    </body>
</html>
```

9.拓展回文检测器的代码，使其可以处理包含空格的回文，如$I   PREFER   PI$是回文

answer 9:

```python
from pythonds.basic import Deque

def palchecker(aSrting):
    cDeque=Deque()
    #去除字符串中的空格
    newstring=aSrting.replace(' ','')

    for ch in newstring:
        cDeque.addRear(ch)

    stillEqual=True

    while cDeque.size() >1 and stillEqual:
        first=cDeque.removeFront()
        last=cDeque.removeRear()
        if first !=last:
            stillEqual=False

    return stillEqual

print(palchecker('I PREFER PI'))
```

output:

```python
True
```



10.本章通过列表中的节点个数来实现length方法，另一种方法是将节点个数作为额外的信息保存在列表头中，请修改UnderedList类的实现，使其包含节点个数信息，并且重新实现length方法

answer 10:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class UnorderedList:
    def __init__(self):
        self.head=None

    def isEmpty(self):
        return self.head==None

    #添加操作，先创建节点，再加入引用
    def add(self,item):
        temp=Node(item)
        temp.setNext(self.head)
        self.head=temp

    #求列表的长度，遍历实现
    def length(self):
        current=self.head
        count=0
        num=0
        while current != None:
            count=count+1
            current=current.getNext()
            num=num+1
        return count,num

    #遍历是否存在指定元素
    def search(self,item):
        current=self.head
        found=False
        while current != None and not found:
            if current.getData()==item:
                found=True
            else:
                current=current.getNext()
        return found

    #移除指定元素
    def remove(self,item):
        current=self.head
        previous=None
        found=False
        while not found:
            if current.getData()==item:
                found=True
            else:
                previous=current
                current=current.getNext()
        if previous==None:
            self.head=current.getNext()
        else:
            previous.setNext(current.getNext())

mylist=UnorderedList()
mylist.add(31)
mylist.add(77)
mylist.add(17)
mylist.add(93)
mylist.add(26)
mylist.add(54)
print(mylist.length())
```

output:

```python
(6,6)
```

11.修改remove方法，使其能处理待移除元素不在列表中的情况

answer 11:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class UnorderedList:
    def __init__(self):
        self.head=None

    def isEmpty(self):
        return self.head==None

    #添加操作，先创建节点，再加入引用
    def add(self,item):
        temp=Node(item)
        temp.setNext(self.head)
        self.head=temp

    #求列表的长度，遍历实现
    def length(self):
        current=self.head
        count=0
        while current != None:
            count=count+1
            current=current.getNext()
        return count

    #遍历是否存在指定元素
    def search(self,item):
        current=self.head
        found=False
        while current != None and not found:
            if current.getData()==item:
                found=True
            else:
                current=current.getNext()
        return found

    #移除指定元素
    def remove(self,item):
        current=self.head
        previous=None
        found=False
        try:
            while not found:
                if current.getData() == item:
                    found = True
                else:
                    previous = current
                    current = current.getNext()
            if previous == None:
                self.head = current.getNext()
            else:
                previous.setNext(current.getNext())
        except:
            return print('待移除元素不存在')

mylist=UnorderedList()
mylist.add(31)
mylist.add(77)
mylist.add(17)
mylist.add(93)
mylist.add(26)
mylist.add(54)
#print(mylist.length())
mylist.remove(18)
```

output:

```python
待移除元素不存在
```



12.实现UnoderedList的_ _str_ _​方法，

answer 12:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class UnorderedList:
    def __init__(self):
        self.head=None

    def __str__(self):
        r=''
        c=self.head
        while c:
            r=r+str(c.getData())
            c=c.getNext()
        return '[' + r + ']'

    def add(self,item):
        temp=Node(item)
        temp.setNext(self.head)
        self.head=temp

    def length(self):
        current=self.head
        count=0
        while current != None:
            count=count+1
            current=current.getNext()
        return count

    def search(self,item):
        current=self.head
        found=False
        while current != None and not found:
            if current.getData()==item:
                found=True
            else:
                current=current.getNext()
        return found

    def remove(self,item):
        current=self.head
        previous=None
        found=False
        while not found:
            if current.getData()==item:
                found=True
            else:
                previous=current
                current=current.getNext()
        if previous==None:
            self.head=current.getNext()
        else:
            previous.setNext(current.getNext())

mylist=UnorderedList()
mylist.add(31)
mylist.add(70)
mylist.add(77)
mylist.add(93)
mylist.add(26)
mylist.add(54)
#print(mylist.length())
print(str(mylist))
```

output:

```python
[542693777031]
```

13.实现无序列表抽象数据类型剩余的方法：append、index、pop、insert

answer 13:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class UnorderedList:
    def __init__(self):
        self.head=None

    def __str__(self):
        r=''
        c=self.head
        while c:
            r=r+str(c.getData())
            c=c.getNext()
        return '[' + r + ']'

    def append(self,item):
        current=self.head
        previous=None
        while current!=None:
            previous=current
            current=current.getNext()
        temp=Node(item)
        temp.setNext(current)
        previous.setNext(temp)

    def index(self,item):
        num=0
        current=self.head
        found=False
        while current!=None and not found:
            if current.getData()==item:
                found=True
            else:
                current=current.getNext()
                num=num+1
        return found,num

    def pop(self):
        current=self.head
        previous=None
        while current!=None:
            previous=current
            if current.getNext()==None:
                previous.setNext(current.getNext())
                x=int(current.getData())
                current=current.getNext()
            else:
                current=current.getNext()
        return x

    def insert(self,pos,item):
        current=self.head
        i=0
        completed=True
        while completed:
            if i==pos:
                temp=Node(item)
                temp.setNext(current.getNext())
                current.setNext(temp)
                completed=False
            else:
                i=i+1
                current=current.getNext()

    def add(self,item):
        temp=Node(item)
        temp.setNext(self.head)
        self.head=temp

mylist=UnorderedList()
mylist.add(86)
mylist.append(31)
mylist.append(70)
mylist.append(77)
mylist.append(93)
mylist.append(26)
mylist.append(54)
print(str(mylist))
print('----------------')
print(mylist.index(70))
print('----------------')
print(mylist.pop())
print('----------------')
mylist.insert(3,65)
print(str(mylist))
```

output:

```python
[86317077932654]
----------------
(True, 2)
----------------
54
----------------
[8631707765932654]
```

14.实现UnorderedLIst的slice方法，该方法接受start和stop两个参数，并且返回一个从start到stop的新列表(不包括stop)

answer 14:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class UnorderedList:
    def __init__(self):
        self.head=None

    def __str__(self):
        r=''
        c=self.head
        while c:
            r=r+str(c.getData())
            c=c.getNext()
        return '[' + r + ']'

    def append(self,item):
        current=self.head
        previous=None
        while current!=None:
            previous=current
            current=current.getNext()
        temp=Node(item)
        temp.setNext(current)
        previous.setNext(temp)

    def slice(self,start,stop):
        new_List=[]
        current_node=self.head
        i=0
        while current_node!=None:
            if i>=start and i<stop:
                new_List.append(int(current_node.getData()))
                current_node=current_node.getNext()
            else:
                current_node=current_node.getNext()
            i=i+1
        return new_List

    def add(self,item):
        temp=Node(item)
        temp.setNext(self.head)
        self.head=temp

mylist=UnorderedList()
mylist.add(86)
mylist.append(31)
mylist.append(70)
mylist.append(77)
mylist.append(93)
mylist.append(26)
mylist.append(54)
print(str(mylist))
print('----------------')
print(mylist.slice(2,4))
```

output:

```python
[86317077932654]
----------------
[70, 77]
```

15.实现有序列表抽象数据类型剩余的方法

answer 15:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class OrderedList:
    def __init__(self):
        self.head=None

    def __str__(self):
        r = ''
        c = self.head
        while c:
            r = r + str(c.getData())
            c = c.getNext()
        return '[' + r + ']'

    def search(self,item):
        current=self.head
        found=False
        stop=False
        while current != None and not found and not stop:
            if current.getData()==item:
                found=True
            else:
                if current.getData()>item:
                    stop=True
                else:
                    current=current.getNext()

        return found

    def remove(self,item):
        current=self.head
        previous=None
        stop=False
        while current!=None and not stop:
            if current.getData()>=item:
                stop=True
            else:
                previous=current
                current=current.getNext()
        if previous==None:
            self.head=current.getNext()
        else:
            previous.setNext(current.getNext())

    def isEmpty(self):
        return self.head==None

    def length(self):
        current = self.head
        count = 0
        while current != None:
            count = count + 1
            current = current.getNext()
        return count

    def index(self,item):
        locate=False
        current=self.head
        i=0
        while not locate:
            if current.getData()==item:
                locate=True
            else:
                current=current.getNext()
            i=i+1
        return i

    def pop(self):
        current = self.head
        previous = None
        while current != None:
            previous = current
            if current.getNext() == None:
                previous.setNext(current.getNext())
                x = int(current.getData())
                current = current.getNext()
            else:
                current = current.getNext()
        return x

    def pop_x(self,pos):
        current=self.head
        previous=None
        i=0
        until=False
        while current!=None and not until:
            if i==pos:
                until=True
                x=int(current.getData())
            else:
                previous=current
                current=current.getNext()
            i=i+1
        if previous==None:
            self.head=current.getNext()
        else:
            previous.setNext(current.getNext())
        return x

    def add(self,item):
        current=self.head
        previous=None
        stop=False
        while current != None and not stop:
            if current.getData()>item:
                stop=True
            else:
                previous=current
                current=current.getNext()

        temp=Node(item)
        if previous==None:
            temp.setNext(self.head)
            self.head=temp
        else:
            temp.setNext(current)
            previous.setNext(temp)

myList=OrderedList()
myList.add(1)
myList.add(2)
myList.add(4)
myList.add(5)
myList.add(3)
print(str(myList))
myList.remove(3)
print(str(myList))
print(myList.isEmpty())
print(myList.length())
print(myList.index(5))
print(myList.pop())
print(myList.pop_x(0))
```

output:

```python
[12345]
[1245]
False
4
4
5
1
```

16.使用链表实现栈，由于栈是先进后出，符合链表添加元素的思想，故方法与前大致相同，栈最重要的几个实现是push()和pop()，故只实现了这两种操作。

answer 16:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class Stack():
    def __init__(self):
        self.head=None

    def __str__(self):
        r = ''
        c = self.head
        while c:
            r = r + str(c.getData())
            c = c.getNext()
        return '[' + r + ']'

    def push(self,item):
        temp = Node(item)
        temp.setNext(self.head)
        self.head = temp

    def pop(self):
        current=self.head
        x=int(current.getData())
        self.head=current.getNext()
        return x

s=Stack()
s.push(12)
s.push(55)
s.push(66)
s.push(77)
s.push(88)
s.push(99)
print(str(s))
print(s.pop())
```

output:

```python
[998877665512]
99
```

17.使用链表实现队列，队列最大的特点是先进先出，与链表添加元素的顺序刚好相反，但是可以结合无序列表中的add和append方法，实现enqueue()操作，dequeue()操作与无序列表的pop()方法一致。

answer 17:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class Queue:
    def __init__(self):
        self.head=None

    def __str__(self):
        r = ''
        c = self.head
        while c:
            r = r + str(c.getData())
            c = c.getNext()
        return '[' + r + ']'

    def isEmpty(self):
        return self.head==None

    def enqueue(self,item):
        current=self.head
        previous=None
        if Queue.isEmpty(self):
            temp1=Node(item)
            temp1.setNext(self.head)
            self.head=temp1
        else:
            while current!=None:
                previous=current
                current=current.getNext()
            temp2=Node(item)
            temp2.setNext(current)
            previous.setNext(temp2)

    def dequeue(self):
        current = self.head
        x = int(current.getData())
        self.head = current.getNext()
        return x

q=Queue()
q.enqueue(1)
q.enqueue(2)
q.enqueue(3)
q.enqueue(4)
q.enqueue(5)
print(str(q))
print(q.dequeue())
```

output:

```python
[12345]
1
```

18.使用链表实现双端队列，对于主要操作：addFront(从前端加入元素)，addRear(从后端加入元素)，RemoveFront(从前端移除元素)，RemoveRear(从后端移除元素)，都可以从之前的方法中结合得到。

answer 18:

```python
class Node:
    def __init__(self,initdata):
        self.data=initdata
        self.next=None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data=newdata

    def setNext(self,newnext):
        self.next=newnext

class Deque:
    def __init__(self):
        self.head=None

    def __str__(self):
        r = ''
        c = self.head
        while c:
            r = r + str(c.getData())
            c = c.getNext()
        return '[' + r + ']'

    def isEmpty(self):
        return self.head==None

    def addFront(self,item):
        temp = Node(item)
        temp.setNext(self.head)
        self.head = temp

    def addRear(self,item):
        current=self.head
        previous=None
        if Deque.isEmpty(self):
            temp1=Node(item)
            temp1.setNext(self.head)
            self.head=temp1
        else:
            while current!=None:
                previous=current
                current=current.getNext()
            temp2=Node(item)
            temp2.setNext(current)
            previous.setNext(temp2)

    def RemoveFront(self):
        current = self.head
        x = int(current.getData())
        self.head = current.getNext()
        return x

    def RemoveRear(self):
        current = self.head
        previous = None
        while current != None:
            previous = current
            if current.getNext() == None:
                previous.setNext(current.getNext())
                y = int(current.getData())
                current = current.getNext()
            else:
                current = current.getNext()
        return y

d=Deque()
d.addFront(1)
d.addFront(2)
d.addFront(3)
print(str(d))
print('------------')
d.addRear(0)
d.addRear(3)
d.addRear(2)
d.addRear(1)
print(str(d))
print('------------')
print(d.RemoveFront())
print('------------')
print(d.RemoveRear())
```

output:

```python
[321]
------------
[3210321]
------------
3
------------
1
```

19.本章提出的链表为单向链表，还有一种双向链表：每一个节点都有指向后一个节点的引用和指向前一个节点的引用，头引用也有两个引用，一个指向链表中的第一个节点，另一个指向最后一个节点

answer 19:

```python
class Node:
    def __init__(self,item):
        self.item=item
        self.next=None
        self.back=None

class DoubleLinkedList:
    def __init__(self):
        self.head=None

    def isEmpty(self):
        return self.head == None

    def add(self, item):
        temp = Node(item)
        if self.isEmpty():
            self.head=temp
        else:
            temp.next=self.head
            self.head.back=temp
            self.head=temp

    def length(self):
        current=self.head
        count=0
        while current!=None:
            count=count+1
            current=current.next
        return count

    def append(self,item):
        node=Node(item)
        if self.isEmpty():
            self.head=node
        else:
            current=self.head
            while current.next!=None:
                current=current.next
            current.next=node
            node.back=current

    def insert(self,pos,item):
        if pos<=0:
            self.add(item)
        elif pos>self.length()-1:
            self.append(item)
        else:
            count=0
            current=self.head
            while count<pos:
                count=count+1
                current=current.next
            node=Node(item)
            node.next=current
            node.back=current.back
            current.back.next=node
            current.back=node

    def remove(self,item):
        current=self.head
        while current !=None:
            if current.item==item:
                if current==self.head:
                    self.head=current.next
                    if current.next:
                        current.next.back=None
                else:
                    current.back.next=current.next
                    if current.next:
                        current.next.back=current.back
                break
            else:
                current=current.next

if __name__=='__main__':
    D=DoubleLinkedList()
    D.add(1)
    D.add(2)
    D.append(3)
    D.insert(2,4)
    D.insert(0,6)
    print(D.length())
```

output:

```python
5
```

双向链表的add，length，isEmpty操作与单向链表相同，其他方法的修改只需注意反向引用的使用即可。
